<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>ExtJs中继承的实现与理解―extend</title>
<style type="text/css">code{display:block;}</style>
<script type="text/javascript" src="ext-base.js"></script>
<script type="text/javascript" src="ext-all.js"></script>
</head>
<body>
<h2>1、Ext中实现类的继承的定义</h2>
<script type="text/javascript">
    function run(v) {
        v = v.split(',');
        for (var i = 0; i < v.length; i++)
            eval(document.getElementById('code' + v[i]).value);
    }
</script>
<p>extend (Object subclass,Object superclass,[Object overrides] : Object) </p>
<p>第一个参数：子类</p>
<p>第二个参数：父类</p>
<p>第三个参数：要覆盖的属性</p>
<p>这里需要强调一下，子类继承下来的是父类中通过superclass.prototype方式定义的属性（包括用此方法定义的函数）,而不继承superclass中的定义的属性和方法，如果子类中的方法名与父类中相同则会覆盖。例子</p>
<p>父类</p>
<p>
<textarea id="code1" rows="10" style="width:100%">
BaseClass = function() {
 f1 = function() {
  alert("f1 in base");
 },
 f2 = function() {
  alert("f2 in base");
 }
}
BaseClass.prototype = {
 f3 : function() {
  alert("f3 in base");
 },
 f4 : function() {
  alert("f4 in base");
 }
};
</textarea>
</p>
<p>
 子类
</p>
<p>
<textarea id="code2" rows="10" style="width:100%">
ChildClass = function() {
}
// 继承
Ext.extend(ChildClass, BaseClass, {
   f1 : function() {
    alert("f1 in child");
   },
   f3 : function() {
    alert("f3 in child");
   }
  });
</textarea>
</p>
<p>
实例化</p>
<p>
<textarea id="code3" rows="10" style="width:100%">
var b = new ChildClass();
b.f1();// 调用子类中的实现
//b.f2();// 会报错，因为子类中没有该方法，并且父类中定义的f2是内部变量，作用域只有在内部可见（闭包）
b.f3();// 继承并覆盖，调用子类的中的实现
b.f4();// 继承，调用父类的中的实现
</textarea>
<input type="button" value="执行" onclick="run('1,2,3');" />
</p>
<p>补充：通过对 JavaScript 的原型继承的了解，可以知道，实例变量的优先级是高于 prototype 的，参见文章<a href="js中静态方法、实例方法、内部方法和原型.htm">js中静态方法、实例方法、内部方法和原型</a> 又如以下例子：</p>
<p>
<textarea id="code4" rows="10" style="width:100%">
BaseClass = function() {
 this.f1 = function() {
  alert("f1 in base");
 },
 this.f2 = function() {
  alert("f2 in base");
 }
}
</textarea>
</p>
<p>子类</p>
<p>
<textarea id="code5" rows="10" style="width:100%">ChildClass = function() {
 ChildClass.superclass.constructor.call( this ); 
}
// 继承
Ext.extend(ChildClass, BaseClass, {
   f1 : function() {
    alert("f1 in child");
   },
   f3 : function() {
    alert("f3 in child");
   }
  });
</textarea>
</p>
<p>实例化</p>
<p>
<textarea id="code6" rows="10" style="width:100%">
var b = new ChildClass();
b.f1();// 调用父类中的实现，注意不会调用子类中的实现
b.f2();// 调用父类中的实现
b.f3();// 调用子类中的实现
</textarea>
<input type="button" value="执行" onclick="run('4,5,6');" />
</p>
<p>分析：在 ChildClass.superclass.constructor.call(this); 这句上， BaseClass 的 f1 成了 ChildClass 的变量，而不是 ChildClass.prototype 。由于实例变量的优先级是高于 prototype 的，所以上面的这个代码是达不到 override 的功能的。</p>
<h2>2、js继承的实现原理</h2>
<p>了解了以上知识，下面讲解一下extend的实现，先看最简单的继承，
实现原理：
<ul>
<li>1、将子类的原型prototype设置为父类的一个实例，也就是说把父类的实例赋值给子类的prototype（这样子类就有了父类原型的所有成员）；</li>
<li>2、重新将子类原型的构造器设置为子类自己，也就是把子类赋值给子类原型的构造器。</li>
</ul>
</p>
<p>以下代码把 child 的 prototype 设置为 parent 的一个实例，然后设置 child.prototype.constructor 为 child。</p>
<p>
<textarea id="code7" rows="10" style="width:100%">
function Extend(child, parent) {
 child.prototype = new parent();
 child.prototype.constructor = child;
}

//父类
function Animal() {
 this.say1 = function() {
  alert("Animal");
 }
}
//子类
function Tiger() {
 this.say2 = function() {
  alert("Tiger");
 }

}
//继承应用
Extend(Tiger, Animal);
var tiger = new Tiger();
tiger.say1();// "Animal"
tiger.say2();// "Tiger"
</textarea>
<input type="button" value="执行" onclick="run('7');" />
</p>
</body>
</html>